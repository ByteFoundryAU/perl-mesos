package mesos;

option java_package = "org.apache.mesos";
option java_outer_classname = "Protos";


enum Status {
  DRIVER_NOT_STARTED = 1;
  DRIVER_RUNNING = 2;
  DRIVER_ABORTED = 3;
  DRIVER_STOPPED = 4;
}


message FrameworkID {
  required string value = 1;
}


message OfferID {
  required string value = 1;
}


message SlaveID {
  required string value = 1;
}


message TaskID {
  required string value = 1;
}


message ExecutorID {
  required string value = 1;
}


message ContainerID {
  required string value = 1;
}


message FrameworkInfo {
  required string user = 1;
  required string name = 2;
  optional FrameworkID id = 3;
  optional double failover_timeout = 4 [default = 0.0];
  optional bool checkpoint = 5 [default = false];
  optional string role = 6 [default = "*"];
}


message CommandInfo {
  message URI {
    required string value = 1;
    optional bool executable = 2;
  }

  repeated URI uris = 1;
  optional Environment environment = 2;
  required string value = 3;
}


message ExecutorInfo {
  required ExecutorID executor_id = 1;
  optional FrameworkID framework_id = 8; // TODO(benh): Make this required.
  required CommandInfo command = 7;
  repeated Resource resources = 5;
  optional string name = 9;

  // Source is an identifier style string used by frameworks to track
  // the source of an executor. This is useful when it's possible for
  // different executor ids to be related semantically.
  // NOTE: Source is exposed alongside the resource usage of the
  // executor via JSON on the slave. This allows users to import
  // usage information into a time series database for monitoring.
  optional string source = 10;
  optional bytes data = 4;
}


message MasterInfo {
  required string id = 1;
  required uint32 ip = 2;
  required uint32 port = 3 [default = 5050];
  optional string pid = 4;
  optional string hostname = 5;
}


message SlaveInfo {
  required string hostname = 1;
  optional int32 port = 8 [default = 5051];
  repeated Resource resources = 3;
  repeated Attribute attributes = 5;
  optional SlaveID id = 6;
  optional bool checkpoint = 7 [default = false];

  // Deprecated!
  optional string webui_hostname = 2;
  optional int32 webui_port = 4 [default = 8081];
}


message Value {
  enum Type {
    SCALAR = 0;
    RANGES = 1;
    SET = 2;
    TEXT = 3;
  }

  message Scalar {
    required double value = 1;
  }

  message Range {
    required uint64 begin = 1;
    required uint64 end = 2;
  }

  message Ranges {
    repeated Range range = 1;
  }

  message Set {
    repeated string item = 1;
  }

  message Text {
    required string value = 1;
  }

  required Type type = 1;
  optional Scalar scalar = 2;
  optional Ranges ranges = 3;
  optional Set set = 4;
  optional Text text = 5;
}


message Attribute {
  required string name = 1;
  required Value.Type type = 2;
  optional Value.Scalar scalar = 3;
  optional Value.Ranges ranges = 4;
  optional Value.Set set = 6;
  optional Value.Text text = 5;
}


message Resource {
  required string name = 1;
  required Value.Type type = 2;
  optional Value.Scalar scalar = 3;
  optional Value.Ranges ranges = 4;
  optional Value.Set set = 5;
  optional string role = 6 [default = "*"];
}


message ResourceStatistics {
  required double timestamp = 1; // Snapshot time, in seconds since the Epoch.

  // CPU Usage Information:
  // Total CPU time spent in user mode, and kernel mode.
  optional double cpus_user_time_secs = 2;
  optional double cpus_system_time_secs = 3;

  // Number of CPUs allocated.
  required double cpus_limit = 4;

  // cpu.stat on process throttling (for contention issues).
  optional uint32 cpus_nr_periods = 7;
  optional uint32 cpus_nr_throttled = 8;
  optional double cpus_throttled_time_secs = 9;

  // Memory Usage Information:
  optional uint64 mem_rss_bytes = 5; // Resident Set Size.

  // Amount of memory resources allocated.
  optional uint64 mem_limit_bytes = 6;

  // Broken out memory usage information (files, anonymous, and mmaped files)
  optional uint64 mem_file_bytes = 10;
  optional uint64 mem_anon_bytes = 11;
  optional uint64 mem_mapped_file_bytes = 12;

  // TODO(bmahler): Add disk usage.
  // TODO(bmahler): Add network usage?
}


message ResourceUsage {
  required SlaveID slave_id = 1;
  required FrameworkID framework_id = 2;

  // Resource usage is for an executor. For tasks launched with
  // an explicit executor, the executor id is provided. For tasks
  // launched without an executor, our internal executor will be
  // used. In this case, we provide the task id here instead, in
  // order to make this message easier for schedulers to work with.

  optional ExecutorID executor_id = 3; // If present, this executor was
  optional string executor_name = 4;   // explicitly specified.

  optional TaskID task_id = 5; // If present, the task did not have an executor.

  // If missing, the isolation module cannot provide resource usage.
  optional ResourceStatistics statistics = 6;
}


message Request {
  optional SlaveID slave_id = 1;
  repeated Resource resources = 2;
}


message Offer {
  required OfferID id = 1;
  required FrameworkID framework_id = 2;
  required SlaveID slave_id = 3;
  required string hostname = 4;
  repeated Resource resources = 5;
  repeated Attribute attributes = 7;
  repeated ExecutorID executor_ids = 6;
}


message TaskInfo {
  required string name = 1;
  required TaskID task_id = 2;
  required SlaveID slave_id = 3;
  repeated Resource resources = 4;
  optional ExecutorInfo executor = 5;
  optional CommandInfo command = 7;
  optional bytes data = 6;
}


enum TaskState {
  TASK_STAGING = 6;  // Initial state. Framework status updates should not use.
  TASK_STARTING = 0;
  TASK_RUNNING = 1;
  TASK_FINISHED = 2; // TERMINAL.
  TASK_FAILED = 3;   // TERMINAL.
  TASK_KILLED = 4;   // TERMINAL.
  TASK_LOST = 5;     // TERMINAL.
}


message TaskStatus {
  required TaskID task_id = 1;
  required TaskState state = 2;
  optional string message = 4; // Possible message explaining state.
  optional bytes data = 3;
  optional SlaveID slave_id = 5;
  optional double timestamp = 6;
}


message Filters {
  // Time to consider unused resources refused. Note that all unused
  // resources will be considered refused and use the default value
  // (below) regardless of whether Filters was passed to
  // SchedulerDriver::launchTasks. You MUST pass Filters with this
  // field set to change this behavior (i.e., get another offer which
  // includes unused resources sooner or later than the default).
  optional double refuse_seconds = 1 [default = 5.0];
}


message Environment {
  message Variable {
    required string name = 1;
    required string value = 2;
  }

  repeated Variable variables = 1;
}


message Parameter {
  required string key = 1;
  required string value = 2;
}


message Parameters {
  repeated Parameter parameter = 1;
}


message Credential {
  required string principal = 1;
  optional bytes secret = 2;
}
