%module{Net::Mesos};
#include <SchedulerDriver.hpp>
#include <NetMesosUtils.hpp>
#include <string>
#include <vector>


%name{Net::Mesos::SchedulerDriver} class mesos::perl::SchedulerDriver
{

%{

static void
xs_init(SV* self, std::string framework, std::string master, std::string credential = std::string())
    PPCODE:
        if (SvROK(self) && SvTYPE(SvRV(self)) == SVt_PVHV) {
            mesos::perl::SchedulerDriver* driver;
            if (credential.length()) {
                driver = new mesos::perl::SchedulerDriver(toMsg<FrameworkInfo>(framework), master, toMsg<Credential>(credential));
            } else {
                driver = new mesos::perl::SchedulerDriver(toMsg<FrameworkInfo>(framework), master);
            }
            sv_magic(SvRV(self), Nullsv, PERL_MAGIC_ext,
                             (const char*) driver, 0);
        }

mesos::perl::MesosChannel*
mesos::perl::SchedulerDriver::_channel()
    CODE:
        RETVAL = THIS->channel_.get();
    OUTPUT:
        RETVAL

mesos::perl::ProxyScheduler*
mesos::perl::SchedulerDriver::proxy_scheduler()
    CODE:
        RETVAL = THIS->proxyScheduler_;
    OUTPUT:
        RETVAL

%}

void start()
    %code{%
        THIS->start();
        XSRETURN_YES;
    %};

void stop(bool failover = false)
    %code{%
        THIS->stop(failover);
        XSRETURN_YES;
    %};

void abort()
    %code{%
        THIS->abort();
        XSRETURN_YES;
    %};

void requestResources(std::vector< std::string > requests)
    %code{%
        THIS->requestResources(toMsg<Request>(requests));
        XSRETURN_YES;
    %};

void launchTasks(std::vector< std::string > offerIds, std::vector< std::string > tasks, std::string filters = std::string())
    %code{%
        if (filters.length()) {
            THIS->launchTasks(toMsg<OfferID>(offerIds), toMsg<TaskInfo>(tasks), toMsg<Filters>(filters));
        } else {
            THIS->launchTasks(toMsg<OfferID>(offerIds), toMsg<TaskInfo>(tasks));
        }
        XSRETURN_YES;
    %};

void launchTask(std::string offerId, std::vector< std::string > tasks, std::string filters = std::string())
    %code{%
        if (filters.length()) {
            THIS->launchTask(toMsg<OfferID>(offerId), toMsg<TaskInfo>(tasks), toMsg<Filters>(filters));
        } else {
            THIS->launchTask(toMsg<OfferID>(offerId), toMsg<TaskInfo>(tasks));
        }
        THIS->launchTask(toMsg<OfferID>(offerId), toMsg<TaskInfo>(tasks));
        XSRETURN_YES;
    %};

void killTask(std::string taskId)
    %code{%
        THIS->killTask(toMsg<TaskID>(taskId));
        XSRETURN_YES;
    %};

void declineOffer(std::string offerId, std::string filters = std::string())
    %code{%
        if (filters.length()) {
            THIS->declineOffer(toMsg<OfferID>(offerId), toMsg<Filters>(filters));
        } else {
            THIS->declineOffer(toMsg<OfferID>(offerId));
        }
        XSRETURN_YES;
    %};

void reviveOffers()
    %code{%
        THIS->reviveOffers();
        XSRETURN_YES;
    %};

void sendFrameworkMessage(std::string executorId, std::string slaveId, std::string data)
    %code{%
        THIS->sendFrameworkMessage(toMsg<ExecutorID>(executorId), toMsg<SlaveID>(slaveId), data);
        XSRETURN_YES;
    %};

void reconcileTasks(std::vector< std::string > statuses)
    %code{%
        THIS->reconcileTasks(toMsg<TaskStatus>(statuses));
        XSRETURN_YES;
    %};

};


