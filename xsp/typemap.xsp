%loadplugin{feature::default_xs_typemap};

%typemap{std::vector< std::string >}{parsed}{
    %xs_type{T_STR_VEC};
    %xs_input_code{%{
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVAV))
                Perl_croak(aTHX_ \"$var is not a ArrayRef\");
        AV* av = (AV*) SvRV($arg);
        int length = av_top_index(av) + 1;
        std::vector<std::string> rvec(length);
        for (int i = 0; i < length; i++) {
            SV** el = av_fetch(av, i, 0);
            rvec.at(i) = std::string(SvPV_nolen(*el), SvCUR(*el));
        }
        $var = rvec;
    }%};
    %xs_output_code{%{
        AV* av = newAV();
        int length = $var.size();
        for (int i = 0; i < length; i++) {
            const std::string& str = $var.at(i);
            SV* val = newSVpvn( str.c_str(), str.size() );
            av_store(av, i, val);
        }
        $arg = sv_2mortal(newRV_noinc((SV*) av));
    }%};
};

%typemap{mesos::perl::SchedulerDriver*}{simple}{
    %name{object};
    %xs_type{O_SCHEDULER_DRIVER};
    %xs_input_code{%{
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVHV))
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\");
        SV* tied_hash = SvRV($arg);
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext);
        $var = ($type) ext_magic->mg_ptr;
    }%};
    %xs_output_code{%{
        HV* stash = gv_stashpv("Net::Mesos::SchedulerDriver", GV_ADDWARN);
        SV* attr_hash = (SV*) newHV();
        sv_magic(attr_hash, Nullsv, PERL_MAGIC_ext,
                         (const char*) $var, 0);
        $arg = sv_bless(sv_2mortal(newRV_noinc(attr_hash)), stash);
    }%};
};

%typemap{mesos::perl::SchedulerChannel*}{simple}{
    %name{object};
    %xs_type{O_SCHEDULER_CHANNEL};
    %xs_input_code{%
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVGV))
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\");
        SV* tied_glob = SvRV($arg);
        MAGIC* ext_magic = mg_find(tied_glob, PERL_MAGIC_ext);
        $var = ($type) ext_magic->mg_ptr;
    %};
    %xs_output_code{%
        HV* stash = gv_stashpv("Net::Mesos::SchedulerChannel", GV_ADDWARN);
        SV* glob = (SV*) newGVgen("Net::Mesos::SchedulerChannel");
        GvIOp(glob) = newIO();
        IoIFP(GvIOp(glob)) = PerlIO_importFILE($var->in_, "r");
        sv_magic(glob, Nullsv, PERL_MAGIC_ext,
                         (const char*) $var, 0);
        $arg = sv_bless(sv_2mortal(newRV_noinc(glob)), stash);
    %};
};
