%loadplugin{feature::default_xs_typemap};

%typemap{std::string};
%typemap{std::vector<std::string>};
%typemap{std::vector< std::string >}{parsed}{%std::vector<std::string>%};
%typemap{Status}{parsed}{
    %xs_type{T_ENUM};
};

%typemap{mesos::perl::ProxyScheduler*}{simple}{ 
    %name{object}; 
    %xs_type{O_PROXY_SCHEDULER}; 
    %xs_input_code{%{ 
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVHV)) 
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\"); 
        SV* tied_hash = SvRV($arg); 
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext); 
        $var = ($type) ext_magic->mg_ptr; 
    }%}; 
    %xs_output_code{%{ 
        HV* stash = gv_stashpv(\"Net::Mesos::ProxyScheduler\", GV_ADDWARN); 
        SV* attr_hash = (SV*) newHV(); 
        sv_magic(attr_hash, Nullsv, PERL_MAGIC_ext, 
                         (const char*) $var, 0); 
        $arg = sv_bless(sv_2mortal(newRV_noinc(attr_hash)), stash); 
    }%}; 
};

%typemap{mesos::perl::SchedulerDriver*}{simple}{
    %name{object};
    %xs_type{O_SCHEDULER_DRIVER};
    %xs_input_code{%{ 
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVHV))
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\"); 
        SV* tied_hash = SvRV($arg); 
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext); 
        $var = ($type) ext_magic->mg_ptr; 
    }%}; 
    %xs_output_code{%{ 
        HV* stash = gv_stashpv(\"Net::Mesos::SchedulerDriver\", GV_ADDWARN); 
        SV* attr_hash = (SV*) newHV(); 
        sv_magic(attr_hash, Nullsv, PERL_MAGIC_ext, 
                         (const char*) $var, 0); 
        $arg = sv_bless(sv_2mortal(newRV_noinc(attr_hash)), stash); 
    }%}; 
};

%typemap{mesos::perl::ExecutorDriver*}{simple}{
    %name{object};
    %xs_type{O_EXECUTOR_DRIVER};
    %xs_input_code{%{ 
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVHV))
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\"); 
        SV* tied_hash = SvRV($arg); 
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext); 
        $var = ($type) ext_magic->mg_ptr; 
    }%}; 
    %xs_output_code{%{ 
        HV* stash = gv_stashpv(\"Net::Mesos::ExecutorDriver\", GV_ADDWARN); 
        SV* attr_hash = (SV*) newHV(); 
        sv_magic(attr_hash, Nullsv, PERL_MAGIC_ext, 
                         (const char*) $var, 0); 
        $arg = sv_bless(sv_2mortal(newRV_noinc(attr_hash)), stash); 
    }%}; 
};

%typemap{mesos::perl::MesosChannel*}{simple}{
    %name{object};
    %xs_type{O_SCHEDULER_CHANNEL};
    %xs_input_code{%{
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVGV))
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\");
        SV* tied_glob = SvRV($arg);
        MAGIC* ext_magic = mg_find(tied_glob, PERL_MAGIC_ext);
        $var = ($type) ext_magic->mg_ptr;
    }%};
    %xs_output_code{%{
        HV* stash = gv_stashpv(\"Net::Mesos::Channel\", GV_ADDWARN);
        SV* glob = (SV*) newGVgen(\"Net::Mesos::Channel\");
        GvIOp(glob) = newIO();
        IoIFP(GvIOp(glob)) = PerlIO_importFILE($var->in_, "r");
        sv_magic(glob, Nullsv, PERL_MAGIC_ext,
                         (const char*) $var, 0);
        $arg = sv_bless(sv_2mortal(newRV_noinc(glob)), stash);
    }%};
};

%typemap{mesos::perl::ProxyExecutor*}{simple}{ 
    %name{object}; 
    %xs_type{O_PROXY_EXECUTOR}; 
    %xs_input_code{%{ 
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVHV)) 
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\"); 
        SV* tied_hash = SvRV($arg); 
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext); 
        $var = ($type) ext_magic->mg_ptr; 
    }%}; 
    %xs_output_code{%{ 
        HV* stash = gv_stashpv(\"Net::Mesos::ProxyExecutor\", GV_ADDWARN); 
        SV* attr_hash = (SV*) newHV(); 
        sv_magic(attr_hash, Nullsv, PERL_MAGIC_ext, 
                         (const char*) $var, 0); 
        $arg = sv_bless(sv_2mortal(newRV_noinc(attr_hash)), stash); 
    }%}; 
};

%typemap{mesos::perl::MesosCommand}{parsed}{
    %name{object};
    %xs_type{O_MESOS_COMMAND};
    %xs_input_code{%{
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVAV))
            Perl_croak(aTHX_ \"$var must be an array ref\");
        AV* command_av = (AV*) SvRV($arg);
        SV* name_sv = *(av_fetch(command_av, 0, 0));
        mesos::perl::CommandArgs args;
        int length = AvFILL(command_av) + 1;
        for (int i = 1; i < length; i++) {
            SV* arg = *(av_fetch(command_av, i, 0));
            args.push_back(sv_to_CommandArg(arg));
        }
        $var = ($type) mesos::perl::MesosCommand(sv_to_string(name_sv), args);
    }%};
    %xs_output_code{%{
        mesos::perl::MesosCommand command((mesos::perl::MesosCommand) $var);
        AV* retval  newAV();
        av_store(retval, 0, newSVpvn(command.name_.c_str(), command.name_.length()));
        for (int i=0; i < command.args_.size(); i++) {
            av_store(retval, i + 1, CommandArg_to_sv( command.args_.at(i) ));
        }
        $arg = sv_2mortal(newRV_noinc((SV*) retval));
    }%};
};
